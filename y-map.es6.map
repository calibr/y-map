{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/Map.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-map.es6","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\r\n'use strict'\r\n\r\nfunction extend (Y /* :any */) {\r\n  class YMap {\r\n    /* ::\r\n    _model: Id;\r\n    os: Y.AbstractDatabase;\r\n    map: Object;\r\n    contents: any;\r\n    opContents: Object;\r\n    eventHandler: Function;\r\n    */\r\n    constructor (os, model, contents, opContents) {\r\n      this._model = model.id\r\n      this.os = os\r\n      this.map = Y.utils.copyObject(model.map)\r\n      this.contents = contents\r\n      this.opContents = opContents\r\n      this.eventHandler = new Y.utils.EventHandler(ops => {\r\n        var userEvents = []\r\n        for (var i in ops) {\r\n          var op = ops[i]\r\n          var oldValue\r\n          // key is the name to use to access (op)content\r\n          var key = op.struct === 'Delete' ? op.key : op.parentSub\r\n\r\n          // compute oldValue\r\n          if (this.opContents[key] != null) {\r\n            let prevType = this.opContents[key]\r\n            oldValue = () => {// eslint-disable-line\r\n              return new Promise((resolve) => {\r\n                this.os.requestTransaction(function *() {// eslint-disable-line\r\n                  var type = yield* this.getType(prevType)\r\n                  resolve(type)\r\n                })\r\n              })\r\n            }\r\n          } else {\r\n            oldValue = this.contents[key]\r\n          }\r\n          // compute op event\r\n          if (op.struct === 'Insert') {\r\n            if (op.left === null) {\r\n              if (op.opContent != null) {\r\n                delete this.contents[key]\r\n                if (op.deleted) {\r\n                  delete this.opContents[key]\r\n                } else {\r\n                  this.opContents[key] = op.opContent\r\n                }\r\n              } else {\r\n                delete this.opContents[key]\r\n                if (op.deleted) {\r\n                  delete this.contents[key]\r\n                } else {\r\n                  this.contents[key] = op.content\r\n                }\r\n              }\r\n              this.map[key] = op.id\r\n              var insertEvent\r\n              if (oldValue === undefined) {\r\n                insertEvent = {\r\n                  name: key,\r\n                  object: this,\r\n                  type: 'add'\r\n                }\r\n              } else {\r\n                insertEvent = {\r\n                  name: key,\r\n                  object: this,\r\n                  oldValue: oldValue,\r\n                  type: 'update'\r\n                }\r\n              }\r\n              userEvents.push(insertEvent)\r\n            }\r\n          } else if (op.struct === 'Delete') {\r\n            if (Y.utils.compareIds(this.map[key], op.target)) {\r\n              delete this.opContents[key]\r\n              delete this.contents[key]\r\n              var deleteEvent = {\r\n                name: key,\r\n                object: this,\r\n                oldValue: oldValue,\r\n                type: 'delete'\r\n              }\r\n              userEvents.push(deleteEvent)\r\n            }\r\n          } else {\r\n            throw new Error('Unexpected Operation!')\r\n          }\r\n        }\r\n        if (userEvents.length > 0) {\r\n          this.eventHandler.callEventListeners(userEvents)\r\n        }\r\n      })\r\n    }\r\n    get (key) {\r\n      // return property.\r\n      // if property does not exist, return null\r\n      // if property is a type, return a promise\r\n      if (key == null) {\r\n        throw new Error('You must specify key!')\r\n      }\r\n      if (this.opContents[key] == null) {\r\n        return this.contents[key]\r\n      } else {\r\n        return new Promise((resolve) => {\r\n          var oid = this.opContents[key]\r\n          this.os.requestTransaction(function *() {\r\n            var type = yield* this.getType(oid)\r\n            resolve(type)\r\n          })\r\n        })\r\n      }\r\n    }\r\n    /*\r\n      If there is a primitive (not a custom type), then return it.\r\n      Returns all primitive values, if propertyName is specified!\r\n      Note: modifying the return value could result in inconsistencies!\r\n        -- so make sure to copy it first!\r\n    */\r\n    getPrimitive (key) {\r\n      if (key == null) {\r\n        return Y.utils.copyObject(this.contents)\r\n      } else {\r\n        return this.contents[key]\r\n      }\r\n    }\r\n    delete (key) {\r\n      var right = this.map[key]\r\n      if (right != null) {\r\n        var del = {\r\n          target: right,\r\n          struct: 'Delete'\r\n        }\r\n        var eventHandler = this.eventHandler\r\n        var modDel = Y.utils.copyObject(del)\r\n        modDel.key = key\r\n        eventHandler.awaitAndPrematurelyCall([modDel])\r\n        this.os.requestTransaction(function *() {\r\n          yield* this.applyCreatedOperations([del])\r\n          eventHandler.awaitedDeletes(1)\r\n        })\r\n      }\r\n    }\r\n    set (key, value) {\r\n      // set property.\r\n      // if property is a type, return a promise\r\n      // if not, apply immediately on this type an call event\r\n\r\n      var right = this.map[key] || null\r\n      var insert /* :any */ = {\r\n        left: null,\r\n        right: right,\r\n        origin: null,\r\n        parent: this._model,\r\n        parentSub: key,\r\n        struct: 'Insert'\r\n      }\r\n      return new Promise((resolve) => {\r\n        if (value instanceof Y.utils.CustomType) {\r\n          // construct a new type\r\n          this.os.requestTransaction(function *() {\r\n            var type = yield* this.createType(value)\r\n            insert.opContent = type._model\r\n            insert.id = this.store.getNextOpId()\r\n            yield* this.applyCreatedOperations([insert])\r\n            resolve(type)\r\n          })\r\n        } else {\r\n          insert.content = value\r\n          insert.id = this.os.getNextOpId()\r\n          var eventHandler = this.eventHandler\r\n          eventHandler.awaitAndPrematurelyCall([insert])\r\n          this.os.requestTransaction(function *() {\r\n            yield* this.applyCreatedOperations([insert])\r\n            eventHandler.awaitedInserts(1)\r\n          })\r\n          resolve(value)\r\n        }\r\n      })\r\n    }\r\n    observe (f) {\r\n      this.eventHandler.addEventListener(f)\r\n    }\r\n    unobserve (f) {\r\n      this.eventHandler.removeEventListener(f)\r\n    }\r\n    /*\r\n      Observe a path.\r\n\r\n      E.g.\r\n      ```\r\n      o.set('textarea', Y.TextBind)\r\n      o.observePath(['textarea'], function(t){\r\n        // is called whenever textarea is replaced\r\n        t.bind(textarea)\r\n      })\r\n\r\n      returns a Promise that contains a function that removes the observer from the path.\r\n    */\r\n    observePath (path, f) {\r\n      var self = this\r\n      function observeProperty (events) {\r\n        // call f whenever path changes\r\n        for (var i = 0; i < events.length; i++) {\r\n          var event = events[i]\r\n          if (event.name === propertyName) {\r\n            // call this also for delete events!\r\n            var property = self.get(propertyName)\r\n            if (property instanceof Promise) {\r\n              property.then(f)\r\n            } else {\r\n              f(property)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (path.length < 1) {\r\n        throw new Error('Path must contain at least one element!')\r\n      } else if (path.length === 1) {\r\n        var propertyName = path[0]\r\n        var property = self.get(propertyName)\r\n        if (property instanceof Promise) {\r\n          property.then(f)\r\n        } else {\r\n          f(property)\r\n        }\r\n        this.observe(observeProperty)\r\n        return Promise.resolve(function () {\r\n          self.unobserve(f)\r\n        })\r\n      } else {\r\n        var deleteChildObservers\r\n        var resetObserverPath = function () {\r\n          var promise = self.get(path[0])\r\n          if (!promise instanceof Promise) {\r\n            // its either not defined or a primitive value\r\n            promise = self.set(path[0], Y.Map)\r\n          }\r\n          return promise.then(function (map) {\r\n            return map.observePath(path.slice(1), f)\r\n          }).then(function (_deleteChildObservers) {\r\n            // update deleteChildObservers\r\n            deleteChildObservers = _deleteChildObservers\r\n            return Promise.resolve() // Promise does not return anything\r\n          })\r\n        }\r\n        var observer = function (events) {\r\n          for (var e in events) {\r\n            var event = events[e]\r\n            if (event.name === path[0]) {\r\n              if (deleteChildObservers != null) {\r\n                deleteChildObservers()\r\n              }\r\n              if (event.type === 'add' || event.type === 'update') {\r\n                resetObserverPath()\r\n              }\r\n              // TODO: what about the delete events?\r\n            }\r\n          }\r\n        }\r\n        self.observe(observer)\r\n        return resetObserverPath().then(\r\n          // this promise contains a function that deletes all the child observers\r\n          // and how to unobserve the observe from this object\r\n          new Promise.resolve(function () { // eslint-disable-line\r\n            if (deleteChildObservers != null) {\r\n              deleteChildObservers()\r\n            }\r\n            self.unobserve(observer)\r\n          })\r\n        )\r\n      }\r\n    }\r\n    * _changed (transaction, op) {\r\n      if (op.struct === 'Delete') {\r\n        var target = yield* transaction.getOperation(op.target)\r\n        op.key = target.parentSub\r\n      }\r\n      this.eventHandler.receivedOp(op)\r\n    }\r\n  }\r\n  Y.extend('Map', new Y.utils.CustomType({\r\n    name: 'Map',\r\n    class: YMap,\r\n    struct: 'Map',\r\n    initType: function * YMapInitializer (os, model) {\r\n      var contents = {}\r\n      var opContents = {}\r\n      var map = model.map\r\n      for (var name in map) {\r\n        var op = yield* this.getOperation(map[name])\r\n        if (op.opContent != null) {\r\n          opContents[name] = op.opContent\r\n        } else {\r\n          contents[name] = op.content\r\n        }\r\n      }\r\n      return new YMap(os, model, contents, opContents)\r\n    }\r\n  }))\r\n}\r\n\r\nmodule.exports = extend\r\nif (typeof Y !== 'undefined') {\r\n  extend(Y)\r\n}\r\n"]}